#!/bin/sh
# use -*-TCL-*- \
exec tclsh "$0" "$@"

########################################################################################
## 10-26-2016 - Renamed script from checkTimingArcsDotLib2 to reportDRC
##            - Changed output format to DRC-style
##            - Added support for -checks/-output/-summary_only/-list_checks
##            - Added summary of all messages
##            - Misc enhancements
## 10-25-2016 - Added checks for max skew and intrinsic_{rise|fall} attribute
## 05-06-2015 - Added checks for internal pins
## 04-01-2015 - Added recovery/removal checks for some of the clock attribute checks
## 03-01-2015 - Added additional checks related to clock attribute 'clock : true' inside
##              Dotlib
## 02-24-2015 - Added check for pins with clock attribute 'clock : true' inside Dotlib
## 10-03-2014 - Initial release
########################################################################################

# Check for missing timing arcs inside Dotlib files.
# The flow is to generate fragment files from Dotlib first with dotlib2tcl
# Once this is done, this script can be run.

set SCRIPT_VERSION {10-26-2016}

# Format: <RuleID> <Enabled> <Severity> <Description>
set DRCDefn [list \
  { {ARC-1}   1  {INFO}     {Pins that are not involved in any timing arc} } \
  { {ARC-2}   1  {INFO}     {Asynchronous pins that are involved in a combinational timing arc} } \
  { {ARC-3}   1  {INFO}     {Pins that have a falling or rising edge arc defined with a negative or positive unate in addition} } \
  { {ARC-4}   1  {INFO}     {Pins that have a setup/hold and recovery/removal timing arcs at the same time} } \
  { {ARC-5}   1  {INFO}     {Pins with min_pulse_width checks} } \
  { {ARC-6}   1  {INFO}     {Missing min_pulse_width checks on clock pins and asynchronous pins} } \
  { {ARC-7}   1  {INFO}     {Pins with min_pulse_width checks but without setup/hold/removal/recovery/edge checks} } \
  { {ARC-8}   1  {INFO}     {Pins with minimum_period checks} } \
  { {ARC-9}   1  {INFO}     {Pins with a function definition} } \
  { {ARC-10}  1  {INFO}     {Pins that have multiple setup/recovery timing arcs} } \
  { {ARC-11}  1  {INFO}     {Pins that have multiple hold/removal timing arcs} } \
  { {ARC-12}  1  {INFO}     {Pins with a clock attribute} } \
  { {ARC-13}  1  {INFO}     {Internal pins} } \
  { {ARC-14}  1  {INFO}     {Internal pins with clock attribute} } \
  { {ARC-15}  1  {INFO}     {Internal pins without clock attribute} } \
  { {ARC-16}  1  {INFO}     {Output pins with a clock attribute} } \
  { {ARC-17}  1  {INFO}     {Pins with min_pulse_width checks and an associated setup/hold/recovery/removal check but without a clock attribute} } \
  { {ARC-18}  1  {INFO}     {Pins with an associated setup/hold/recovery/removal check and a clock attribute but without a min_pulse_width} } \
  { {ARC-19}  1  {INFO}     {Pins with min_pulse_width checks and a clock attribute but without setup/hold/recovery/removal check associated} } \
  { {ARC-20}  1  {INFO}     {Pins with a clock attribute but without related setup/hold/recovery/removal check} } \
  { {ARC-21}  1  {INFO}     {Pins with a related setup/hold/recovery/removal check but without a clock attribute} } \
  { {ARC-22}  1  {INFO}     {Pins with an associated removal/recovery check but without a clock attribute} } \
  { {ARC-23}  1  {WARNING}  {Pins with max skew checks but without an intrinsic_{rise|fall} attribute} } \
  { {ARC-24}  1  {INFO}     {Pins with intrinsic_{rise|fall} attribute and no max skew check} } \
  { {ARC-25}  0  {INFO}     {Pins with max skew check and intrinsic_{rise|fall} attribute} } \
  { {ARC-26}  1  {INFO}     {Pins with same-edge max skew check} } \
  { {ARC-27}  1  {INFO}     {Pins with opposite-edge max skew check} } \
  ]

lappend auto_path /home/dpefour/git/scripts/toolbox
package require toolbox

lappend auto_path /wrk/hdstaff/dpefour/support/Olympus/assets/sqlite3.8.0.2
package require sqlite3

# Execute the SQL command. When failed, retry until the database is unlocked
proc wait_db_ready { &SQL {cmd {pragma integrity_check} } } {
  upvar &SQL SQL
  # Wait for the database to be unlocked
  while {[catch { SQL eval $cmd } errorstring]} {
    if {[regexp {database is locked} $errorstring]} {
      puts "SQL database locked ..."
      exec sleep 1
    } elseif {[regexp {attempt to write a readonly database} $errorstring]} {
      puts "SQL database read-only ..."
      exec sleep 1
    } else {
      error $errorstring
    }
  }
  return 0
}

proc getDRCSeverity {rule} {
  global DRCDefn
  set severity {N/A}
  foreach elm $DRCDefn {
    foreach {r - s d} $elm { break }
    if {$r == $rule} {
      set severity $s
      break
    }
  }
  return $severity
}

proc getDRCDesciption {rule} {
  global DRCDefn
  set description {N/A}
  foreach elm $DRCDefn {
    foreach {r - s d} $elm { break }
    if {$r == $rule} {
      set description $d
      break
    }
  }
  return $description
}

proc isDRCEnabled {rule} {
  global DRCDefn
  set enabled 1
  foreach elm $DRCDefn {
    foreach {r e - -} $elm { break }
    if {$r == $rule} {
      set enabled $e
      break
    }
  }
  return $enabled
}

proc drc {rule msg} {
  global rules
  global DRCDefn
  set rule [string toupper $rule]
  set severity [getDRCSeverity $rule]
  if {![info exists rules($rule)]} { set rules($rule) 0 }
  set idx [incr rules($rule)]
  return [format {    %s: %s [%s#%s]} $severity $msg $rule $idx]
}

# SQLite3 database
# set filename {sqlite3.db}
set filename {}

# Build the list of rules to be checked
set allrules [list]
for {set idx 0} {$idx < 100} {incr idx} {
  lappend allrules [format {ARC-%s} $idx]
}

catch {unset rules}
set output [list]
set showChecks 0
set summaryOnly 0
set channel {stdout}
set ofilename {}
set VERBOSE 0
set DEBUG 0
set error 0
set show_help 0
if {[llength $argv] == 0} {
  incr show_help
}
#-------------------------------------------------------
# Process command line arguments
#-------------------------------------------------------
while {[llength $argv]} {
  set name [::tb::lshift argv]
  switch -regexp -- $name {
    {^-db} {
      set filename [::tb::lshift argv]
    }
    {^-o(u(t(p(ut?)?)?)?)?$} {
      set ofilename [::tb::lshift argv]
    }
    {^-su(m(m(a(r(y(_(o(n(ly?)?)?)?)?)?)?)?)?)?} {
      set summaryOnly 1
    }
    {^-c(h(e(c(ks?)?)?)?)?} {
      set allrules [::tb::lshift argv]
    }
    {^-li(s(t(_(c(h(e(c(ks?)?)?)?)?)?)?)?)?} {
      set showChecks 1
    }
    {^-v(e(r(b(o(se?)?)?)?)?)?$} {
        set VERBOSE 1
    }
    {^-d(e(b(ug?)?)?)?$} {
        set DEBUG 1
        set VERBOSE 1
    }
    {^-h(e(lp?)?)?$} {
        incr show_help
    }
    default {
        if {[string match "-*" $name]} {
          puts " -E- option '$name' is not a valid option"
          incr error
        } else {
          puts " -E- option '$name' is not a valid option"
          incr error
        }
    }
  }
}

if {$show_help} {
  # <-- HELP
  puts [format {
    Usage: reportDRC
                [-db <sqlite3 database>]
                [-output <filename>]
                [-summary_only]
                [-checks <list_checks>]
                [-list_checks]
                [-verbose|-v]
                [-help|-h]

    Description: Utility to perform various Dotlib checks on the SQLite3 database

    Version: %s

    Example:
       reportDRC -output drc.rpt
       reportDRC -db './kintex7.db'
       reportDRC -db './kintex7.db' -checks 'ARC-2 ARC10' -output drc.rpt
       reportDRC -db './kintex7.db' -summary_only -output drc_summary.rpt

  } $SCRIPT_VERSION ]
  # HELP -->

  exit 0
}

if {$error} {
  puts "\n Some error(s) occured. Cannot continue.\n"
  exit -1
}

if {$showChecks} {
  # Only show DRC checks
  set tbl [::tb::prettyTable]
  $tbl header [list {Rule} {Severity} {Description}]
  $tbl configure -indent 2
  foreach elm $DRCDefn {
    foreach {rule enabled severity description} $elm { break }
    if {!$enabled} {
      continue
    }
    $tbl addrow [list $rule $severity $description]
  }
  puts [$tbl print]
  catch {$tbl destroy}
  # Now exit
  exit 0
}

if {$ofilename != {}} {
  set channel [open $ofilename {w}]
}

# SQLite3 database
if {![file exists $filename]} {
  error " File '$filename' does not exist"
}

# Open SQLite3 database
sqlite3 SQL $filename -readonly true
wait_db_ready SQL

# Get database version
set dbVersion [SQL eval { SELECT value FROM param WHERE property='version' LIMIT 1; } ]

set cells [SQL eval { SELECT name FROM cell ORDER BY name ASC }]


if {([lsearch $allrules [set DRCRULE {ARC-1}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins that are not involved in any timing arc
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  # Get all the pins that are involved in a timing arc
  set pinids [concat [SQL eval { SELECT DISTINCT relatedpinid FROM arc; }] \
                     [SQL eval { SELECT DISTINCT pinid FROM arc; }] \
             ]
  SQL eval "
    SELECT cell.name AS 'cell',
           pin.name AS 'pin'
    FROM pin
      JOIN cell ON cell.id = pin.cellid
    WHERE
      pin.id NOT IN ('[join $pinids ',']')
    ORDER BY cell.name, pin.name;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) $values(pin)
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach pin [::tb::collapseBusNames $DB($cell)] {
#       lappend output "   No timing arc association found for pin $pin"
      lappend output [drc $DRCRULE "No timing arc association found for pin $pin"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-2}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for asynchronous pins that are involved in a combinational timing arc
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  catch {unset dir}
  set DB(cells) [list]

  SQL eval {
    SELECT (SELECT name FROM cell WHERE id=cellid) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT name FROM pin WHERE id=relatedpinid) AS "relatedpin",
           (SELECT direction FROM pin WHERE id=relatedpinid) AS "direction"
    FROM arc
    WHERE
      ((SELECT timing_type FROM timing WHERE id = arc.timingid) LIKE "%combinational%" )
      AND (relatedpinid IN (SELECT pinid FROM timing WHERE timing_type LIKE "%removal%" OR timing_type LIKE "%recovery%" ))
  } values {
    lappend DB(cells) $values(cell)
    if {![info exists DB($values(cell):$values(relatedpin))]} { set DB($values(cell):$values(relatedpin)) [list] }
    lappend DB($values(cell):$values(relatedpin)) $values(pin)
    set dir($values(cell):$values(relatedpin)) $values(direction)
  }

#   SQL eval {
#     SELECT (SELECT name FROM cell WHERE id=cellid) AS "cell",
#            (SELECT name FROM pin WHERE id=pinid) AS "pin",
#            (SELECT name FROM pin WHERE id=relatedpinid) AS "relatedpin",
#            (SELECT direction FROM pin WHERE id=relatedpinid) AS "direction"
#     FROM arc
#     WHERE
#       timingid IN (SELECT id FROM timing WHERE timing_type LIKE "%combinational%" )
#       AND (relatedpinid IN (SELECT pinid FROM timing WHERE timing_type LIKE "%removal%" OR timing_type LIKE "%recovery%" ))
#   } values {
#     lappend DB(cells) $values(cell)
#     if {![info exists DB($values(cell):$values(relatedpin))]} { set DB($values(cell):$values(relatedpin)) [list] }
#     lappend DB($values(cell):$values(relatedpin)) $values(pin)
#     set dir($values(cell):$values(relatedpin)) $values(direction)
#   }

  foreach cell [lsort -dictionary [lsort -dictionary -unique $DB(cells)]] {
    lappend output " Processing $cell"
    set pins [list]
    foreach elm [array names DB ${cell}:*] {
      lappend pins [regsub "${cell}:" $elm {}]
    }
    set pins [lsort -dictionary -unique $pins]
    # Do NOT collapse pins with [::tb::collapseBusNames $pins] since it does not sense here
    # and can result in trying to acess associative array with invalid key
    foreach pin $pins {
#       lappend output "   Combinational arc found from asynchronous $dir(${cell}:${pin}) pin '$pin' to pin(s) '[::tb::collapseBusNames [lsort -unique $DB(${cell}:${pin})]]'"
      lappend output [drc $DRCRULE "Combinational arc found from asynchronous $dir(${cell}:${pin}) pin '$pin' to pin(s) '[::tb::collapseBusNames [lsort -unique $DB(${cell}:${pin})]]'"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-3}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins that have a falling or rising edge arc defined with a negative or positive unate in addition
  # Timing check from Brandon:
  #   if {{timing_type==falling_edge || timing_type==rising_edge} && {timing_sense==”negative_unate” || timing_sense==”positive_unate”}}
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  catch {unset dir}
  SQL eval {
    SELECT (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      (timing_type LIKE "%falling_edge%" OR timing_type LIKE "%rising_edge%")
      AND (timing_sense LIKE "%negative_unate%" OR timing_sense LIKE "%positive_unate%")
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) $values(pin)
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach pin [::tb::collapseBusNames $DB($cell)] {
#       lappend output "   Found pin '$pin' with falling_edge or rising_edge (timing_type) and negative_unate or positive_unate (timing_sense)"
      lappend output [drc $DRCRULE "Found pin '$pin' with falling_edge or rising_edge (timing_type) and negative_unate or positive_unate (timing_sense)"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-4}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins that have a setup/hold and recovery/removal timing arcs at the same time
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  catch {unset dir}
  set pinids [SQL eval {
    SELECT pinid FROM arc WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%') OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
    INTERSECT
    SELECT pinid FROM arc WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%') OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
    ;
  }]
  SQL eval "
    SELECT (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense'
    FROM arc
    WHERE
      pinid IN ('[join $pinids ',']')
      AND (
          ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
          )
    ORDER BY cellid, relatedpinid, pinid;
  " values {
#     lappend output " -I- $values(cell): $values(relatedpin) -> $values(pin) ($values(timing_type), $values(timing_sense))"
    lappend output [drc $DRCRULE "$values(cell): $values(relatedpin) -> $values(pin) ($values(timing_type), $values(timing_sense))"]
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-5}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for existing min_pulse_width checks
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      timing_type = 'min_pulse_width'
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check"
      lappend output [drc $DRCRULE "Found $dir pin '$pin' with 'min_pulse_width' check"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-6}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for missing min_pulse_width checks on clock pins and asynchronous pins
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  # Find id of clock pins
  set clockpinids [lsort -unique [SQL eval {
    SELECT DISTINCT relatedpinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  # Find id of asynchronous pins
  set asyncpinids [lsort -unique [SQL eval {
    SELECT DISTINCT pinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
    ;
  }] ]
  # Find id of pins that have a min_pulse_width check
  set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
           id,
           name AS 'pin',
           direction
    FROM pin
    WHERE ( pin.id IN ('[join $clockpinids ',']')
            OR pin.id IN ('[join $asyncpinids ',']')
          )
          AND pin.id NOT IN ('[join $minpulsewidthpinids ',']')
    ORDER BY cell, pin;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {id pin dir} $elm { break }
      if {[lsearch $clockpinids $id] != -1} {
#         lappend output "   Found clock $dir pin '$pin' with missing 'min_pulse_width' check"
        lappend output [drc $DRCRULE "Found clock $dir pin '$pin' with missing 'min_pulse_width' check"]
      } else {
#         lappend output "   Found asynchronous $dir pin '$pin' with missing 'min_pulse_width' check"
        lappend output [drc $DRCRULE "Found asynchronous $dir pin '$pin' with missing 'min_pulse_width' check"]
      }
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-7}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with min_pulse_width checks but without setup/hold/removal/recovery/edge checks (FROM/TO)
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  # Find id of pins with setup/hold/removal/recovery/edge (FROM/TO)
  set pinids [lsort -unique [SQL eval {
    SELECT DISTINCT pinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  set relatedpinids [lsort -unique [SQL eval {
    SELECT DISTINCT relatedpinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  # Find id of pins that have a min_pulse_width check
  set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
           id,
           name AS 'pin',
           direction
    FROM pin
    WHERE ( pin.id NOT IN ('[join $pinids ',']')
            AND pin.id NOT IN ('[join $relatedpinids ',']')
          )
          AND pin.id IN ('[join $minpulsewidthpinids ',']')
    ORDER BY cell, pin;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {id pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and no other setup/hold/removal/recovery/edge check associated"
      lappend output [drc $DRCRULE "Found $dir pin '$pin' with 'min_pulse_width' check and no other setup/hold/removal/recovery/edge check associated"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-8}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for existing minimum_period checks
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      timing_type = 'minimum_period'
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'minimum_period' check"
      lappend output [drc $DRCRULE "Found $dir pin '$pin' with 'minimum_period' check"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-9}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with a function definition
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
           name AS "pin",
           direction,
           function
    FROM pin
    WHERE
      function IS NOT NULL
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction) $values(function)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
    lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir function} $elm { break }
#       lappend output "   Found $dir pin '$pin' with function '$function'"
      lappend output [drc $DRCRULE "Found $dir pin '$pin' with function '$function'"]
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-10}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins that have multiple setup/recovery timing arcs
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  set DB(_) [list]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT direction FROM pin WHERE id=pinid) AS 'direction',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense',
           (SELECT fpga_arc_condition FROM timing WHERE timing.id=arc.timingid) AS 'fpga_condition'
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
    ORDER BY cell, relatedpin, pin;
  " values {
    if {![info exists DB($values(cell):$values(pin))]} { set DB($values(cell):$values(pin)) [list] }
    lappend DB($values(cell):$values(pin)) [list $values(relatedpin) $values(pin) $values(direction) $values(timing_type) $values(timing_sense) $values(fpga_condition)]
    lappend DB(_) $values(cell)
  }

  foreach cell [lsort -dictionary -unique $DB(_)] {
    set first 1
    foreach key [lsort -dictionary [array names DB ${cell}:*]] {
      regexp {.+\:(.+)$} $key - pin
      catch { unset ar }
      # Now it becomes overly complicated since we need to sort the list of arcs per fpga condition
      foreach elm $DB(${cell}:${pin}) {
        foreach {relatedpin pin dir timing_type timing_sense fpga_condition} $elm { break }
        if {![info exists ar($fpga_condition)]} { set ar($fpga_condition) [list] }
        lappend ar($fpga_condition) [list $relatedpin $pin $dir $timing_type $timing_sense ]
      }
      # Let's iterate through all the fpga conditions that were found for this cell&pin
      # so that we can check whether a particular fpga condition has more than 1 setup/recovery
      # arc
      foreach fpgacond [lsort -dictionary [array names ar]] {
        if {[llength $ar($fpgacond)] > 1} {
          set count 1
          foreach elm [lsort -dictionary -index 1 $ar($fpgacond)] {
            foreach {relatedpin pin dir timing_type timing_sense} $elm { break }
            if {$first} {
              lappend output " Processing $cell"
              set first 0
            }
            if {$fpgacond != {}} {
#               lappend output "   Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
              lappend output [drc $DRCRULE "Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"]
            } else {
#               lappend output "   Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
              lappend output [drc $DRCRULE "Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"]
            }
            incr count
          }
        }
      }
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-11}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins that have multiple hold/removal timing arcs
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  catch {unset DB}
  set DB(_) [list]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT direction FROM pin WHERE id=pinid) AS 'direction',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense',
           (SELECT fpga_arc_condition FROM timing WHERE timing.id=arc.timingid) AS 'fpga_condition'
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
    ORDER BY cell, relatedpin, pin;
  " values {
    if {![info exists DB($values(cell):$values(pin))]} { set DB($values(cell):$values(pin)) [list] }
    lappend DB($values(cell):$values(pin)) [list $values(relatedpin) $values(pin) $values(direction) $values(timing_type) $values(timing_sense) $values(fpga_condition)]
    lappend DB(_) $values(cell)
  }

  foreach cell [lsort -dictionary -unique $DB(_)] {
    set first 1
    foreach key [lsort -dictionary [array names DB ${cell}:*]] {
      regexp {.+\:(.+)$} $key - pin
      catch { unset ar }
      # Now it becomes overly complicated since we need to sort the list of arcs per fpga condition
      foreach elm $DB(${cell}:${pin}) {
        foreach {relatedpin pin dir timing_type timing_sense fpga_condition} $elm { break }
        if {![info exists ar($fpga_condition)]} { set ar($fpga_condition) [list] }
        lappend ar($fpga_condition) [list $relatedpin $pin $dir $timing_type $timing_sense ]
      }
      # Let's iterate through all the fpga conditions that were found for this cell&pin
      # so that we can check whether a particular fpga condition has more than 1 hold/removal
      # arc
      foreach fpgacond [lsort -dictionary [array names ar]] {
        if {[llength $ar($fpgacond)] > 1} {
          set count 1
          foreach elm [lsort -dictionary -index 1 $ar($fpgacond)] {
            foreach {relatedpin pin dir timing_type timing_sense} $elm { break }
            if {$first} {
              lappend output " Processing $cell"
              set first 0
            }
            if {$fpgacond != {}} {
#               lappend output "   Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
              lappend output [drc $DRCRULE "Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"]
            } else {
#               lappend output "   Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
              lappend output [drc $DRCRULE "Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"]
            }
            incr count
          }
        }
      }
    }
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-12}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with a clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute '$clock'"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with clock attribute '$clock'"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-13}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for internal pins
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        direction = 'internal'
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin'"
        lappend output [drc $DRCRULE "Found $dir pin '$pin'"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-14}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for internal pins with clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
        AND (direction = 'internal')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with clock attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-15}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for internal pins without clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NULL
        AND (direction = 'internal')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' without clock attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' without clock attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-16}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for output pins with a clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
        AND (direction = 'output')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute '$clock'"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with clock attribute '$clock'"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-17}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with min_pulse_width checks and an associated setup/hold/recovery/removal check but without a clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $minpulsewidthpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and setup/hold check associated and no 'clock : true' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with 'min_pulse_width' check and setup/hold check associated and no 'clock : true' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-18}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with an associated setup/hold/recovery/removal check and a clock attribute but without a min_pulse_width
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $minpulsewidthpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a setup/hold check associated and a 'clock : true' attribute but without 'min_pulse_width' check"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with a setup/hold check associated and a 'clock : true' attribute but without 'min_pulse_width' check"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-19}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with min_pulse_width checks and a clock attribute but without setup/hold/recovery/removal check associated
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id NOT IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $minpulsewidthpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and  a 'clock : true' attribute but without setup/hold check associated"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with 'min_pulse_width' check and  a 'clock : true' attribute but without setup/hold check associated"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-20}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with a clock attribute but without related setup/hold/recovery/removal check
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id NOT IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a 'clock : true' attribute but without setup/hold check associated"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with a 'clock : true' attribute but without setup/hold check associated"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-21}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with a related setup/hold/recovery/removal check but without a clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a setup/hold check associated but without a 'clock : true' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with a setup/hold check associated but without a 'clock : true' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-22}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with an associated removal/recovery check but without a clock attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with removal/recovery (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a removal/recovery check associated but without a 'clock : true' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with a removal/recovery check associated but without a 'clock : true' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-23}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with skew_{rising|falling} checks but without an intrinsic_{rise|fall} attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with skew_{rising|falling} and no intrinsic_{rise|fall}
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = '')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = '')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and no 'intrinsic_{rise|fall}' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and no 'intrinsic_{rise|fall}' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-24}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with intrinsic_{rise|fall} attribute and no skew_{rising|falling} check
  # (recovery/removal checks are filtered out)
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ## (recovery/removal checks are filtered out)
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and no skew_{rising|falling}
    # Note: recovery/removal timing arcs are filtered out as they could be inside the Dotlib
    # for PT compatibility but ignored by Vivado
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%skew_rising%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%skew_falling%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%recovery%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%removal%')
               AND ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-25}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with skew_{rising|falling} check and intrinsic_{rise|fall} attribute
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling}
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-26}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with same-edge skew_{rising|falling} check
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling} (SAME EDGE)
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'rise')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'fall')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

if {([lsearch $allrules [set DRCRULE {ARC-27}]] != -1) && [isDRCEnabled $DRCRULE]} {
  # Search for pins with opposite-edge skew_{rising|falling} check
  lappend output [format {
 #######################################################################################################################
 ##
 ## %s [%s]
 ##
 #######################################################################################################################
} [getDRCDesciption $DRCRULE] $DRCRULE]

  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling} (OPPOSITE EDGE)
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'fall')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'rise')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
      lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        lappend output [drc $DRCRULE "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"]
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK BY CURRENT DATABASE VERSION ($dbVersion)"
  }

}

########################################################################################
########################################################################################

# Print report
if {!$summaryOnly} {
  foreach line $output {
    puts $channel $line
  }
}

# Print summary
  puts $channel [format {
########################################################################################
##
## Summary of messages
##
########################################################################################
}]
set tbl [::tb::prettyTable]
$tbl header [list {Rule} {Severity} {Messages} {Description}]
$tbl configure -indent 2
foreach elm $DRCDefn {
  foreach {rule enabled severity description} $elm { break }
  if {!$enabled && $DEBUG} {
    if {[lsearch $allrules $rule] == -1} {
      continue
    }
    $tbl addrow [list $rule $severity {Disabled} $description]
    continue
  } elseif {!$enabled} {
    continue
  }
  if {![info exists rules($rule)]} { set rules($rule) 0 }
  set num $rules($rule)
  if {($num == 0) && ($VERBOSE == 0)} {
    continue
  }
  if {[lsearch $allrules $rule] == -1} {
    continue
  }
  $tbl addrow [list $rule $severity $num $description]
}
puts $channel [$tbl print]
catch {$tbl destroy}

# Closing the output file
if {($channel != {stdout}) && ($channel != {})} {
  close $channel
  set channel {}
  puts " -I- Generated file [file normalize $ofilename]"
}

# Closing the SQLite3 database
SQL close

exit 0
