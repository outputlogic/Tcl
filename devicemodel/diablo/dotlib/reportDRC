#!/bin/sh
# use -*-TCL-*- \
exec tclsh "$0" "$@"

########################################################################################
## 11-03-2016 - Added support for -format/-csv/-table/-file
##            - Added support for waivers (-waivers/-show_waivers)
##            - Reformated message for ARC-4
## 10-27-2016 - Renamed script from checkTimingArcsDotLib2 to reportDRC
##            - Added support to multiple databases
##            - Changed output format to DRC-style
##            - Added support for -checks/-summary_only/-list_checks
##            - Added support for -output/-source/-no_violation_number
##            - Added summary of all messages
##            - Misc enhancements
## 10-25-2016 - Added checks for max skew and intrinsic_{rise|fall} attribute
## 05-06-2015 - Added checks for internal pins
## 04-01-2015 - Added recovery/removal checks for some of the clock attribute checks
## 03-01-2015 - Added additional checks related to clock attribute 'clock : true' inside
##              Dotlib
## 02-24-2015 - Added check for pins with clock attribute 'clock : true' inside Dotlib
## 10-03-2014 - Initial release
########################################################################################

# Check for missing timing arcs inside Dotlib files.
# The flow is to generate fragment files from Dotlib first with dotlib2tcl
# Once this is done, this script can be run.

set SCRIPT_VERSION {11-03-2016}

# Format: <RuleID> <Enabled> <Severity> <Description>
set DRCDefn [list \
  { {ARC-1}   1  {INFO}     {Pins that are not involved in any timing arc} } \
  { {ARC-2}   1  {INFO}     {Asynchronous pins that are involved in a combinational timing arc} } \
  { {ARC-3}   1  {INFO}     {Pins that have a falling or rising edge arc defined with a negative or positive unate in addition} } \
  { {ARC-4}   1  {INFO}     {Pins that have a setup/hold and recovery/removal timing arcs at the same time} } \
  { {ARC-5}   1  {INFO}     {Pins with min_pulse_width checks} } \
  { {ARC-6}   1  {INFO}     {Missing min_pulse_width checks on clock pins and asynchronous pins} } \
  { {ARC-7}   1  {INFO}     {Pins with min_pulse_width checks but without setup/hold/removal/recovery/edge checks} } \
  { {ARC-8}   1  {INFO}     {Pins with minimum_period checks} } \
  { {ARC-9}   1  {INFO}     {Pins with a function definition} } \
  { {ARC-10}  1  {INFO}     {Pins that have multiple setup/recovery timing arcs} } \
  { {ARC-11}  1  {INFO}     {Pins that have multiple hold/removal timing arcs} } \
  { {ARC-12}  1  {INFO}     {Pins with a clock attribute} } \
  { {ARC-13}  1  {INFO}     {Internal pins} } \
  { {ARC-14}  1  {INFO}     {Internal pins with clock attribute} } \
  { {ARC-15}  1  {INFO}     {Internal pins without clock attribute} } \
  { {ARC-16}  1  {INFO}     {Output pins with a clock attribute} } \
  { {ARC-17}  1  {INFO}     {Pins with min_pulse_width checks and an associated setup/hold/recovery/removal check but without a clock attribute} } \
  { {ARC-18}  1  {INFO}     {Pins with an associated setup/hold/recovery/removal check and a clock attribute but without a min_pulse_width} } \
  { {ARC-19}  1  {INFO}     {Pins with min_pulse_width checks and a clock attribute but without setup/hold/recovery/removal check associated} } \
  { {ARC-20}  1  {INFO}     {Pins with a clock attribute but without related setup/hold/recovery/removal check} } \
  { {ARC-21}  1  {INFO}     {Pins with a related setup/hold/recovery/removal check but without a clock attribute} } \
  { {ARC-22}  1  {INFO}     {Pins with an associated removal/recovery check but without a clock attribute} } \
  { {ARC-23}  1  {WARNING}  {Pins with max skew checks but without an intrinsic_{rise|fall} attribute} } \
  { {ARC-24}  1  {INFO}     {Pins with intrinsic_{rise|fall} attribute and no max skew check} } \
  { {ARC-25}  0  {INFO}     {Pins with max skew check and intrinsic_{rise|fall} attribute} } \
  { {ARC-26}  1  {INFO}     {Pins with same-edge max skew check} } \
  { {ARC-27}  1  {INFO}     {Pins with opposite-edge max skew check} } \
  ]

# Adding custom DRC:
#  - Use '-source <filename>' to import the Tcl file with new DRC(s)
#  - Use '-check' if necessary to only run new DRC(s)
#  - The Tcl variables $cell/$pin/$relatedpin should be defined
#    before calling 'drc' command
#   proc ARC-xxxx {} {
#     global SQL output dbVersion
#     catch {unset DB}
#     SQL eval {
#       SELECT DISTINCT
#              (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
#              name AS "pin",
#              ...
#              ...
#       FROM pin
#       WHERE
#              ...
#       ORDER BY cell, pin;
#     } values {
#       if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
#       lappend DB($values(cell)) [list $values(pin) ...]
#     }
#
#     foreach cell [lsort -dictionary [array names DB]] {
#       foreach elm $DB($cell) {
#         foreach {pin ...} $elm { break }
#         drc "Found $dir pin '$pin' with function '$function'"
#       }
#     }
#     return -code ok
#   }
#
#   add_drc ARC-xxxx <SEVERITY> <DESCRIPTION>


lappend auto_path /home/dpefour/git/scripts/toolbox
package require toolbox

lappend auto_path /wrk/hdstaff/dpefour/support/Olympus/assets/sqlite3.8.0.2
package require sqlite3

# Execute the SQL command. When failed, retry until the database is unlocked
proc wait_db_ready { &SQL {cmd {pragma integrity_check} } } {
  upvar &SQL SQL
  # Wait for the database to be unlocked
  while {[catch { SQL eval $cmd } errorstring]} {
    if {[regexp {database is locked} $errorstring]} {
      puts "SQL database locked ..."
      exec sleep 1
    } elseif {[regexp {attempt to write a readonly database} $errorstring]} {
      puts "SQL database read-only ..."
      exec sleep 1
    } else {
      error $errorstring
    }
  }
  return 0
}

# E.g:
#   add_drc {ARC-1}   {INFO}     {Pins that are not involved in any timing arc}
#   add_drc {ARC-25}  {INFO}     {Pins with max skew check and intrinsic_{rise|fall} attribute}   0
proc add_drc {rule severity description {enabled 1}} {
  global DRCDefn
  lappend DRCDefn [list $rule $enabled $severity $description]
  return -code ok
}

proc getDRCSeverity {rule} {
  global DRCDefn
  set severity {N/A}
  foreach elm $DRCDefn {
    foreach {r - s d} $elm { break }
    if {$r == $rule} {
      set severity $s
      break
    }
  }
  return $severity
}

proc getDRCDescription {rule} {
  global DRCDefn
  set description {N/A}
  foreach elm $DRCDefn {
    foreach {r - s d} $elm { break }
    if {$r == $rule} {
      set description $d
      break
    }
  }
  return $description
}

proc isDRCEnabled {rule} {
  global DRCDefn
  set enabled 1
  foreach elm $DRCDefn {
    foreach {r e - -} $elm { break }
    if {$r == $rule} {
      set enabled $e
      break
    }
  }
  return $enabled
}

proc drc {msg} {
  global DRCDefn rules showViolationNum csv waivers
  # Name of the caller proc
  set rule [info level 1]
  # Try to get the Tcl variables cell/pin/relatedpin from the caller
  upvar 1 cell cell ; if {![info exists cell]} { set cell {} }
  upvar 1 pin pin ; if {![info exists pin]} { set pin {} }
  upvar 1 relatedpin relatedpin ; if {![info exists relatedpin]} { set relatedpin {} }
  if {![info exists rules($rule)]} { set rules($rule) 0 }
  if {![info exists waivers($rule)]} { set waivers($rule) 0 }
  # Is DRC waived?
  if {[info exists waivers(${rule}\0${cell}\0${pin}\0${relatedpin})]} {
    # Increment the number of times the DRC is waived
    incr waivers(${rule}\0${cell}\0${pin}\0${relatedpin})
    incr waivers($rule)
    # Set '-' as violation number
    set idx {-}
    set isWaived {Y}
#     # Return
#     return -code ok
  } else {
    # No waiver exists.
    set idx [incr rules($rule)]
    set isWaived {}
  }
  set severity [getDRCSeverity $rule]
  lappend csv [list $rule $severity $cell $pin $relatedpin $msg $idx $isWaived]
  return -code ok
}

proc read-waivers {filename} {
  global waivers
  set tbl [::tb::prettyTable]
  read-csv tbl $filename {,}
#   puts [$tbl print]
  set header [$tbl header]
  set colRule -1
  set colCell -1
  set colPin -1
  set colRelatedPin -1
  # E.g: "Rule","Severity","Cell","Pin","Related Pin","Message"
  for {set i 0} {$i < [llength $header]} {incr i} {
    switch -nocase -regexp -- [lindex $header $i] {
      {^Rule$} {
        set colRule $i
      }
      {^Cell$} {
        set colCell $i
      }
      {^Pin$} {
        set colPin $i
      }
      {^Related Pin$} {
        set colRelatedPin $i
      }
    }
  }
  if {($colRule == -1) || ($colCell == -1) || ($colPin == -1) || ($colRelatedPin == -1)} {
    error " -E- some of the column(s) 'Rule'/'Cell'/'Pin'/'Relate Pin' could not be found"
  }
  foreach row [$tbl gettable] {
    set rule [lindex $row $colRule]
    set cell [lindex $row $colCell]
    set pin [lindex $row $colPin]
    set relatedpin [lindex $row $colRelatedPin]
    set waivers(${rule}\0${cell}\0${pin}\0${relatedpin}) 0
  }
  puts " -I- Number of imported waiver(s): [llength [$tbl gettable]]"
  catch {$tbl destroy}
  return -code ok
}

# Read CSV file and return a Table object
proc read-csv {&tbl filename {csvDelimiter ,} {parseHeader 1}} {
  global VERBOSE DEBUG
  if {![file exists $filename]} {
    error " -E- file '$filename' does not exist"
  }
  upvar 1 ${&tbl} tbl
  set FH [open $filename]
  set first 1
  set count 0
  while {![eof $FH]} {
    gets $FH line
    # Skip comments and empty lines
    if {[regexp {^\s*#} $line]} { continue }
    if {[regexp {^\s*$} $line]} { continue }
    if {$first} {
      set header [split-csv $line $csvDelimiter]
      if {[subst $${tbl}::header] != {}} {
        # If we are in merge mode, then check that the header for this CSV file
        # does match the existing header
        if {$parseHeader} {
          if {![lequal [subst $${tbl}::header] $header]} {
            if {$DEBUG} {
              puts " -I- CSV header: $header"
              puts " -I- Table header: [subst $${tbl}::header]"
            }
            puts " -W- The CSV header does not match. File $filename skipped"
            return 1
          }
        }
      }
      if {$parseHeader} {
        $tbl header $header
      } else {
        # If the CSV file has no header, create an empty header with correct number
        # of columns and add the first line as a row
        set L [list] ; foreach el $header { lappend L {} }
        $tbl header $L
        $tbl addrow $header
        incr count
      }
      set first 0
    } else {
      $tbl addrow [split-csv $line $csvDelimiter]
      incr count
    }
  }
  close $FH
  if {$DEBUG} {
    puts " -I- Header: $header"
    puts " -I- Number of imported row(s): $count"
  }
  return 0
}

# Convert a CSV string to a Tcl list based on a field separator
proc split-csv { str {sepChar ,} } {
  regsub -all {(\A\"|\"\Z)} $str \0 str
  set str [string map [list $sepChar\"\"$sepChar $sepChar$sepChar] $str]
  set str [string map [list $sepChar\"\"\" $sepChar\0\" \
                            \"\"\"$sepChar \"\0$sepChar \
                            $sepChar\"\"$sepChar $sepChar$sepChar \
                           \"\" \" \
                           \" \0 \
                           ] $str]
  set end 0
  while {[regexp -indices -start $end {(\0)[^\0]*(\0)} $str \
          -> start end]} {
      set start [lindex $start 0]
      set end   [lindex $end 0]
      set range [string range $str $start $end]
      set first [string first $sepChar $range]
      if {$first >= 0} {
          set str [string replace $str $start $end \
              [string map [list $sepChar \1] $range]]
      }
      incr end
  }
  set str [string map [list $sepChar \0 \1 $sepChar \0 {} ] $str]
  return [split $str \0]
}

# SQLite3 database
# set filename {sqlite3.db}
set filename {}

# List of rules to be checked
set allrules [list]

# Waivers
catch {unset waivers}

set output [list]
set csv [list]
set oformat {default}; # default|table|csv
set showWaivers 0
set showChecks 0
set summaryOnly 0
set channel {stdout}
set ifilename {}
set ofilename {}
set sfilename {}
set wfilename {}
set showViolationNum 1
set VERBOSE 0
set DEBUG 0
set error 0
set show_help 0
if {[llength $argv] == 0} {
  incr show_help
}
#-------------------------------------------------------
# Process command line arguments
#-------------------------------------------------------
while {[llength $argv]} {
  set name [::tb::lshift argv]
  switch -regexp -- $name {
    {^-db$} {
      while {![string match "-*" [set filename [::tb::lshift argv]]]} {
        if {$filename == {}} {
          break
        }
        foreach file [glob -nocomplain $filename] {
          if {![file exists $file]} {
            puts " -E- file '$file' does not exist"
            incr error
          } else {
            lappend ifilename $file
          }
        }
      }
      # The last argument needs to be put back on the stack
      if {$filename != {}} { ::tb::unlshift argv $filename }
    }
    {^-fi(le?)?$} -
    {^-o(u(t(p(ut?)?)?)?)?$} {
      set ofilename [::tb::lshift argv]
    }
    {^-w(a(i(v(e(rs?)?)?)?)?)?$} {
      set wfilename [::tb::lshift argv]
    }
    {^-fo(r(m(at?)?)?)?$} {
      set oformat [::tb::lshift argv]
    }
    {^-csv?$} {
      set oformat {csv}
    }
    {^-ta(b(le?)?)?$} {
      set oformat {table}
    }
    {^-so(u(r(ce?)?)?)?$} {
      set sfilename [::tb::lshift argv]
    }
    {^-su(m(m(a(r(y(_(o(n(ly?)?)?)?)?)?)?)?)?)?$} {
      set summaryOnly 1
    }
    {^-c(h(e(c(ks?)?)?)?)?$} {
      # Supports both space and coma between checks
      foreach elm [::tb::lshift argv] {
        foreach el [split $elm ,] {
          # Uppercase the DRC rule name
          lappend allrules [string toupper $el]
        }
      }
    }
    {^-li(s(t(_(c(h(e(c(ks?)?)?)?)?)?)?)?)?$} {
      set showChecks 1
    }
    {^-no(_(v(i(o(l(a(t(i(o(n(_(n(u(m(b(er?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?$} {
      set showViolationNum 0
    }
    {^-sh(o(w(_(w(a(i(v(e(rs?)?)?)?)?)?)?)?)?)?$} {
      set showWaivers 1
    }
    {^-v(e(r(b(o(se?)?)?)?)?)?$} {
        set VERBOSE 1
    }
    {^-d(e(b(ug?)?)?)?$} {
        set DEBUG 1
        set VERBOSE 1
    }
    {^-h(e(lp?)?)?$} {
        incr show_help
    }
    default {
        if {[string match "-*" $name]} {
          puts " -E- option '$name' is not a valid option"
          incr error
        } else {
          puts " -E- option '$name' is not a valid option"
          incr error
        }
    }
  }
}

if {$show_help} {
  # <-- HELP
  puts [format {
    Usage: reportDRC
                [-db <sqlite3 database(s)>]
                [-output <filename>|-file <filename>]
                [-format <default|table|csv>][-table][-csv]
                [-summary_only]
                [-checks <list_checks>]
                [-list_checks]
                [-no_violation_number]
                [-source <filename>]
                [-waivers <filename>]
                [-show_waivers]
                [-verbose|-v]
                [-help|-h]

    Description: Utility to run Dotlib Rule Checks on the SQLite3 database

    Version: %s

    Use -source to add custom DRCs. Custom DRCs should be registered with 'add_drc' command.
    Use -no_violation_number to remove the violation number from the report.
    Use -checks to provide a coma-delimited list of rules.
    Use -waivers/-show_waivers to use and report waivers.

    Example:
       reportDRC -db './kintex7.db'
       reportDRC -db './kintex*.db' -checks 'ARC-2,ARC10' -output drc.rpt
       reportDRC -db ./*/kintex*.db -summary_only -output drc_summary.rpt
       reportDRC -db './kintex7.db' -source extradrcs.tcl -output drc_summary.rpt

  } $SCRIPT_VERSION ]
  # HELP -->

  exit 0
}

if {$wfilename != {}} {
  if {[catch {read-waivers $wfilename} errorstring]} {
    puts "$errorstring"
    incr error
  }
}

if {[llength $ifilename] == 0} {
  puts " -E- no input database specified"
  incr error
}

if {($sfilename != {}) && ![file exists $sfilename]} {
  puts " -E- file '$sfilename' does not exist"
  incr error
}

if {![regexp {^(default|csv|table)$} $oformat]} {
  puts " -E- invalid output format '$oformat'"
  incr error
}

if {$error} {
  puts "\n Some error(s) occured. Cannot continue.\n"
  exit -1
}

########################################################################################
# DRC rules
########################################################################################

# Search for pins that are not involved in any timing arc
proc ARC-1 {} {
  global SQL output dbVersion
  catch {unset DB}
  # Get all the pins that are involved in a timing arc
  set pinids [concat [SQL eval { SELECT DISTINCT relatedpinid FROM arc; }] \
                     [SQL eval { SELECT DISTINCT pinid FROM arc; }] \
             ]
  SQL eval "
    SELECT cell.name AS 'cell',
           pin.name AS 'pin'
    FROM pin
      JOIN cell ON cell.id = pin.cellid
    WHERE
      pin.id NOT IN ('[join $pinids ',']')
    ORDER BY cell.name, pin.name;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) $values(pin)
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach pin [::tb::collapseBusNames $DB($cell)] {
#       lappend output "   No timing arc association found for pin $pin"
      drc "No timing arc association found for pin $pin"
    }
  }
  return -code ok
}

# Search for asynchronous pins that are involved in a combinational timing arc
proc ARC-2 {} {
  global SQL output dbVersion
  catch {unset DB}
  catch {unset dir}
  set DB(cells) [list]

  SQL eval {
    SELECT (SELECT name FROM cell WHERE id=cellid) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT name FROM pin WHERE id=relatedpinid) AS "relatedpin",
           (SELECT direction FROM pin WHERE id=relatedpinid) AS "direction"
    FROM arc
    WHERE
      ((SELECT timing_type FROM timing WHERE id = arc.timingid) LIKE "%combinational%" )
      AND (relatedpinid IN (SELECT pinid FROM timing WHERE timing_type LIKE "%removal%" OR timing_type LIKE "%recovery%" ))
  } values {
    lappend DB(cells) $values(cell)
    if {![info exists DB($values(cell):$values(relatedpin))]} { set DB($values(cell):$values(relatedpin)) [list] }
    lappend DB($values(cell):$values(relatedpin)) $values(pin)
    set dir($values(cell):$values(relatedpin)) $values(direction)
  }

#   SQL eval {
#     SELECT (SELECT name FROM cell WHERE id=cellid) AS "cell",
#            (SELECT name FROM pin WHERE id=pinid) AS "pin",
#            (SELECT name FROM pin WHERE id=relatedpinid) AS "relatedpin",
#            (SELECT direction FROM pin WHERE id=relatedpinid) AS "direction"
#     FROM arc
#     WHERE
#       timingid IN (SELECT id FROM timing WHERE timing_type LIKE "%combinational%" )
#       AND (relatedpinid IN (SELECT pinid FROM timing WHERE timing_type LIKE "%removal%" OR timing_type LIKE "%recovery%" ))
#   } values {
#     lappend DB(cells) $values(cell)
#     if {![info exists DB($values(cell):$values(relatedpin))]} { set DB($values(cell):$values(relatedpin)) [list] }
#     lappend DB($values(cell):$values(relatedpin)) $values(pin)
#     set dir($values(cell):$values(relatedpin)) $values(direction)
#   }

  foreach cell [lsort -dictionary [lsort -dictionary -unique $DB(cells)]] {
#     lappend output " Processing $cell"
    set pins [list]
    foreach elm [array names DB ${cell}:*] {
      lappend pins [regsub "${cell}:" $elm {}]
    }
    set pins [lsort -dictionary -unique $pins]
    # Do NOT collapse pins with [::tb::collapseBusNames $pins] since it does not sense here
    # and can result in trying to acess associative array with invalid key
    foreach pin $pins {
      set relatedpin [::tb::collapseBusNames [lsort -unique $DB(${cell}:${pin})]]
#       lappend output "   Combinational arc found from asynchronous $dir(${cell}:${pin}) pin '$pin' to pin(s) '[::tb::collapseBusNames [lsort -unique $DB(${cell}:${pin})]]'"
      drc "Combinational arc found from asynchronous $dir(${cell}:${pin}) pin '$pin' to pin(s) '$relatedpin'"
    }
  }
  return -code ok
}

# Search for pins that have a falling or rising edge arc defined with a negative or positive unate in addition
# Timing check from Brandon:
#   if {{timing_type==falling_edge || timing_type==rising_edge} && {timing_sense==”negative_unate” || timing_sense==”positive_unate”}}
proc ARC-3 {} {
  global SQL output dbVersion
  catch {unset DB}
  catch {unset dir}
  SQL eval {
    SELECT (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      (timing_type LIKE "%falling_edge%" OR timing_type LIKE "%rising_edge%")
      AND (timing_sense LIKE "%negative_unate%" OR timing_sense LIKE "%positive_unate%")
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) $values(pin)
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach pin [::tb::collapseBusNames $DB($cell)] {
#       lappend output "   Found pin '$pin' with falling_edge or rising_edge (timing_type) and negative_unate or positive_unate (timing_sense)"
      drc "Found pin '$pin' with falling_edge or rising_edge (timing_type) and negative_unate or positive_unate (timing_sense)"
    }
  }
  return -code ok
}

# Search for pins that have a setup/hold and recovery/removal timing arcs at the same time
proc ARC-4 {} {
  global SQL output dbVersion
  catch {unset DB}
  catch {unset dir}
  set pinids [SQL eval {
    SELECT pinid FROM arc WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%') OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
    INTERSECT
    SELECT pinid FROM arc WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%') OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
    ;
  }]
  SQL eval "
    SELECT (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense'
    FROM arc
    WHERE
      pinid IN ('[join $pinids ',']')
      AND (
          ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
          OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
          )
    ORDER BY cellid, pinid, relatedpinid;
  " values {
#     lappend output " -I- $values(cell): $values(relatedpin) -> $values(pin) ($values(timing_type), $values(timing_sense))"
    set cell $values(cell)
    set pin $values(pin)
    set relatedpin $values(relatedpin)
    drc "Found pin '$pin' with a setup/hold and recovery/removal timing arcs at the same time ($values(timing_type), $values(timing_sense))"
  }
  return -code ok
}

# Search for existing min_pulse_width checks
proc ARC-5 {} {
  global SQL output dbVersion
  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      timing_type = 'min_pulse_width'
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check"
      drc "Found $dir pin '$pin' with 'min_pulse_width' check"
    }
  }
  return -code ok
}

# Search for missing min_pulse_width checks on clock pins and asynchronous pins
proc ARC-6 {} {
  global SQL output dbVersion
  catch {unset DB}
  # Find id of clock pins
  set clockpinids [lsort -unique [SQL eval {
    SELECT DISTINCT relatedpinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  # Find id of asynchronous pins
  set asyncpinids [lsort -unique [SQL eval {
    SELECT DISTINCT pinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
    ;
  }] ]
  # Find id of pins that have a min_pulse_width check
  set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
           id,
           name AS 'pin',
           direction
    FROM pin
    WHERE ( pin.id IN ('[join $clockpinids ',']')
            OR pin.id IN ('[join $asyncpinids ',']')
          )
          AND pin.id NOT IN ('[join $minpulsewidthpinids ',']')
    ORDER BY cell, pin;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {id pin dir} $elm { break }
      if {[lsearch $clockpinids $id] != -1} {
#         lappend output "   Found clock $dir pin '$pin' with missing 'min_pulse_width' check"
        drc "Found clock $dir pin '$pin' with missing 'min_pulse_width' check"
      } else {
#         lappend output "   Found asynchronous $dir pin '$pin' with missing 'min_pulse_width' check"
        drc "Found asynchronous $dir pin '$pin' with missing 'min_pulse_width' check"
      }
    }
  }
  return -code ok
}

# Search for pins with min_pulse_width checks but without setup/hold/removal/recovery/edge checks (FROM/TO)
proc ARC-7 {} {
  global SQL output dbVersion
  catch {unset DB}
  # Find id of pins with setup/hold/removal/recovery/edge (FROM/TO)
  set pinids [lsort -unique [SQL eval {
    SELECT DISTINCT pinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  set relatedpinids [lsort -unique [SQL eval {
    SELECT DISTINCT relatedpinid
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%edge%')
    ;
  }] ]
  # Find id of pins that have a min_pulse_width check
  set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
           id,
           name AS 'pin',
           direction
    FROM pin
    WHERE ( pin.id NOT IN ('[join $pinids ',']')
            AND pin.id NOT IN ('[join $relatedpinids ',']')
          )
          AND pin.id IN ('[join $minpulsewidthpinids ',']')
    ORDER BY cell, pin;
  " values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {id pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and no other setup/hold/removal/recovery/edge check associated"
      drc "Found $dir pin '$pin' with 'min_pulse_width' check and no other setup/hold/removal/recovery/edge check associated"
    }
  }
  return -code ok
}

# Search for existing minimum_period checks
proc ARC-8 {} {
  global SQL output dbVersion
  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = (SELECT cellid FROM pin WHERE id=pinid) ) AS "cell",
           (SELECT name FROM pin WHERE id=pinid) AS "pin",
           (SELECT direction FROM pin WHERE id=pinid) AS "direction"
    FROM timing
    WHERE
      timing_type = 'minimum_period'
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir} $elm { break }
#       lappend output "   Found $dir pin '$pin' with 'minimum_period' check"
      drc "Found $dir pin '$pin' with 'minimum_period' check"
    }
  }
  return -code ok
}

# Search for pins with a function definition
proc ARC-9 {} {
  global SQL output dbVersion
  catch {unset DB}
  SQL eval {
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
           name AS "pin",
           direction,
           function
    FROM pin
    WHERE
      function IS NOT NULL
    ORDER BY cell, pin;
  } values {
    if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
    lappend DB($values(cell)) [list $values(pin) $values(direction) $values(function)]
  }

  foreach cell [lsort -dictionary [array names DB]] {
#     lappend output " Processing $cell"
    foreach elm $DB($cell) {
      foreach {pin dir function} $elm { break }
#       lappend output "   Found $dir pin '$pin' with function '$function'"
      drc "Found $dir pin '$pin' with function '$function'"
    }
  }
  return -code ok
}

# Search for pins that have multiple setup/recovery timing arcs
proc ARC-10 {} {
  global SQL output dbVersion
  catch {unset DB}
  set DB(_) [list]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT direction FROM pin WHERE id=pinid) AS 'direction',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense',
           (SELECT fpga_arc_condition FROM timing WHERE timing.id=arc.timingid) AS 'fpga_condition'
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
    ORDER BY cell, relatedpin, pin;
  " values {
    if {![info exists DB($values(cell):$values(pin))]} { set DB($values(cell):$values(pin)) [list] }
    lappend DB($values(cell):$values(pin)) [list $values(relatedpin) $values(pin) $values(direction) $values(timing_type) $values(timing_sense) $values(fpga_condition)]
    lappend DB(_) $values(cell)
  }

  foreach cell [lsort -dictionary -unique $DB(_)] {
    set first 1
    foreach key [lsort -dictionary [array names DB ${cell}:*]] {
      regexp {.+\:(.+)$} $key - pin
      catch { unset ar }
      # Now it becomes overly complicated since we need to sort the list of arcs per fpga condition
      foreach elm $DB(${cell}:${pin}) {
        foreach {relatedpin pin dir timing_type timing_sense fpga_condition} $elm { break }
        if {![info exists ar($fpga_condition)]} { set ar($fpga_condition) [list] }
        lappend ar($fpga_condition) [list $relatedpin $pin $dir $timing_type $timing_sense ]
      }
      # Let's iterate through all the fpga conditions that were found for this cell&pin
      # so that we can check whether a particular fpga condition has more than 1 setup/recovery
      # arc
      foreach fpgacond [lsort -dictionary [array names ar]] {
        if {[llength $ar($fpgacond)] > 1} {
          set count 1
          foreach elm [lsort -dictionary -index 1 $ar($fpgacond)] {
            foreach {relatedpin pin dir timing_type timing_sense} $elm { break }
            if {$first} {
          #     lappend output " Processing $cell"
              set first 0
            }
            if {$fpgacond != {}} {
#               lappend output "   Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
              drc "Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
            } else {
#               lappend output "   Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
              drc "Found $dir pin '$pin' with multiple setup/recovery checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
            }
            incr count
          }
        }
      }
    }
  }
  return -code ok
}

# Search for pins that have multiple hold/removal timing arcs
proc ARC-11 {} {
  global SQL output dbVersion
  catch {unset DB}
  set DB(_) [list]
  SQL eval "
    SELECT DISTINCT
           (SELECT name FROM cell WHERE id=cellid) AS 'cell',
           (SELECT direction FROM pin WHERE id=pinid) AS 'direction',
           (SELECT name FROM pin WHERE id=pinid) AS 'pin',
           (SELECT name FROM pin WHERE id=relatedpinid) AS 'relatedpin',
           (SELECT timing_type FROM timing WHERE timing.id=arc.timingid) AS 'timing_type',
           (SELECT timing_sense FROM timing WHERE timing.id=arc.timingid) AS 'timing_sense',
           (SELECT fpga_arc_condition FROM timing WHERE timing.id=arc.timingid) AS 'fpga_condition'
           FROM arc
           WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
              OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
    ORDER BY cell, relatedpin, pin;
  " values {
    if {![info exists DB($values(cell):$values(pin))]} { set DB($values(cell):$values(pin)) [list] }
    lappend DB($values(cell):$values(pin)) [list $values(relatedpin) $values(pin) $values(direction) $values(timing_type) $values(timing_sense) $values(fpga_condition)]
    lappend DB(_) $values(cell)
  }

  foreach cell [lsort -dictionary -unique $DB(_)] {
    set first 1
    foreach key [lsort -dictionary [array names DB ${cell}:*]] {
      regexp {.+\:(.+)$} $key - pin
      catch { unset ar }
      # Now it becomes overly complicated since we need to sort the list of arcs per fpga condition
      foreach elm $DB(${cell}:${pin}) {
        foreach {relatedpin pin dir timing_type timing_sense fpga_condition} $elm { break }
        if {![info exists ar($fpga_condition)]} { set ar($fpga_condition) [list] }
        lappend ar($fpga_condition) [list $relatedpin $pin $dir $timing_type $timing_sense ]
      }
      # Let's iterate through all the fpga conditions that were found for this cell&pin
      # so that we can check whether a particular fpga condition has more than 1 hold/removal
      # arc
      foreach fpgacond [lsort -dictionary [array names ar]] {
        if {[llength $ar($fpgacond)] > 1} {
          set count 1
          foreach elm [lsort -dictionary -index 1 $ar($fpgacond)] {
            foreach {relatedpin pin dir timing_type timing_sense} $elm { break }
            if {$first} {
          #     lappend output " Processing $cell"
              set first 0
            }
            if {$fpgacond != {}} {
#               lappend output "   Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
              drc "Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])\t($fpgacond)"
            } else {
#               lappend output "   Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
              drc "Found $dir pin '$pin' with multiple hold/removal checks ('$timing_type' with related pin '$relatedpin')($count/[llength $ar($fpgacond)])"
            }
            incr count
          }
        }
      }
    }
  }
  return -code ok
}

# Search for pins with a clock attribute
proc ARC-12 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute '$clock'"
        drc "Found $dir pin '$pin' with clock attribute '$clock'"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for internal pins
proc ARC-13 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        direction = 'internal'
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin'"
        drc "Found $dir pin '$pin'"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for internal pins with clock attribute
proc ARC-14 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
        AND (direction = 'internal')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute"
        drc "Found $dir pin '$pin' with clock attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for internal pins without clock attribute
proc ARC-15 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NULL
        AND (direction = 'internal')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' without clock attribute"
        drc "Found $dir pin '$pin' without clock attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for output pins with a clock attribute
proc ARC-16 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    SQL eval {
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS "cell",
             name AS "pin",
             direction,
             clock
      FROM pin
      WHERE
        clock IS NOT NULL
        AND (direction = 'output')
      ORDER BY cell, pin;
    } values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(pin) $values(direction) $values(clock)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {pin dir clock} $elm { break }
#         lappend output "   Found $dir pin '$pin' with clock attribute '$clock'"
        drc "Found $dir pin '$pin' with clock attribute '$clock'"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with min_pulse_width checks and an associated setup/hold/recovery/removal check but without a clock attribute
proc ARC-17 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $minpulsewidthpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and setup/hold check associated and no 'clock : true' attribute"
        drc "Found $dir pin '$pin' with 'min_pulse_width' check and setup/hold check associated and no 'clock : true' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with an associated setup/hold/recovery/removal check and a clock attribute but without a min_pulse_width
proc ARC-18 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $minpulsewidthpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a setup/hold check associated and a 'clock : true' attribute but without 'min_pulse_width' check"
        drc "Found $dir pin '$pin' with a setup/hold check associated and a 'clock : true' attribute but without 'min_pulse_width' check"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with min_pulse_width checks and a clock attribute but without setup/hold/recovery/removal check associated
proc ARC-19 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a min_pulse_width check
    set minpulsewidthpinids [lsort -unique [SQL eval { SELECT DISTINCT pinid FROM timing WHERE timing_type = 'min_pulse_width' }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id NOT IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $minpulsewidthpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with 'min_pulse_width' check and  a 'clock : true' attribute but without setup/hold check associated"
        drc "Found $dir pin '$pin' with 'min_pulse_width' check and  a 'clock : true' attribute but without setup/hold check associated"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with a clock attribute but without related setup/hold/recovery/removal check
proc ARC-20 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id NOT IN ('[join $relatedpinids ',']')
            AND pin.id IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a 'clock : true' attribute but without setup/hold check associated"
        drc "Found $dir pin '$pin' with a 'clock : true' attribute but without setup/hold check associated"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with a related setup/hold/recovery/removal check but without a clock attribute
proc ARC-21 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with setup/hold (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%setup%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%hold%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a setup/hold check associated but without a 'clock : true' attribute"
        drc "Found $dir pin '$pin' with a setup/hold check associated but without a 'clock : true' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with an associated removal/recovery check but without a clock attribute
proc ARC-22 {} {
  global SQL output dbVersion
  # Only for database version from 1.6 and upward
  if {$dbVersion >= 1.6} {
    catch {unset DB}
    # Find id of pins with removal/recovery (FROM)
    set relatedpinids [lsort -unique [SQL eval {
      SELECT DISTINCT relatedpinid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%recovery%')
                OR ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%removal%')
      ;
    }] ]
    # Find id of pins that have a clock attribute
    set clockpinids [lsort -unique [SQL eval { SELECT DISTINCT id FROM pin WHERE clock IS NOT NULL }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = pin.cellid ) AS 'cell',
             id,
             name AS 'pin',
             direction
      FROM pin
      WHERE pin.id IN ('[join $relatedpinids ',']')
            AND pin.id NOT IN ('[join $clockpinids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir} $elm { break }
#         lappend output "   Found $dir pin '$pin' with a removal/recovery check associated but without a 'clock : true' attribute"
        drc "Found $dir pin '$pin' with a removal/recovery check associated but without a 'clock : true' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with skew_{rising|falling} checks but without an intrinsic_{rise|fall} attribute
proc ARC-23 {} {
  global SQL output dbVersion
  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with skew_{rising|falling} and no intrinsic_{rise|fall}
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = '')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = '')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and no 'intrinsic_{rise|fall}' attribute"
        drc "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and no 'intrinsic_{rise|fall}' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with intrinsic_{rise|fall} attribute and no skew_{rising|falling} check
# (recovery/removal checks are filtered out)
proc ARC-24 {} {
  global SQL output dbVersion
  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and no skew_{rising|falling}
    # Note: recovery/removal timing arcs are filtered out as they could be inside the Dotlib
    # for PT compatibility but ignored by Vivado
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%skew_rising%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%skew_falling%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%recovery%')
               AND ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) NOT LIKE '%removal%')
               AND ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        drc "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with skew_{rising|falling} check and intrinsic_{rise|fall} attribute
proc ARC-25 {} {
  global SQL output dbVersion
  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling}
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) != '')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        drc "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with same-edge skew_{rising|falling} check
proc ARC-26 {} {
  global SQL output dbVersion
  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling} (SAME EDGE)
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'rise')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'fall')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        drc "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}

# Search for pins with opposite-edge skew_{rising|falling} check
proc ARC-27 {} {
  global SQL output dbVersion
  # Only for database version from 1.7 and upward
  if {$dbVersion >= 1.7} {
    catch {unset DB}
    # Find id of timing with intrinsic_{rise|fall} and skew_{rising|falling} (OPPOSITE EDGE)
    set timingids [lsort -unique [SQL eval {
      SELECT DISTINCT timingid
             FROM arc
             WHERE ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_rising%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'fall')
                   )
                OR ( ((SELECT timing_type FROM timing WHERE timing.id=arc.timingid) LIKE '%skew_falling%')
                     AND
                     ((SELECT intrinsic FROM timing WHERE timing.id=arc.timingid) = 'rise')
                   )
      ;
    }] ]
    SQL eval "
      SELECT DISTINCT
             (SELECT name FROM cell WHERE id = arc.cellid ) AS 'cell',
             (SELECT name FROM pin WHERE id = arc.pinid ) AS 'pin',
             (SELECT name FROM pin WHERE id = arc.relatedpinid ) AS 'relatedpin',
             (SELECT direction FROM pin WHERE id = arc.pinid ) AS 'direction',
             (SELECT timing_type FROM timing WHERE id = arc.timingid ) AS 'timing_type',
             (SELECT intrinsic FROM timing WHERE id = arc.timingid ) AS 'intrinsic',
             id
      FROM arc
      WHERE arc.timingid IN ('[join $timingids ',']')
      ORDER BY cell, pin;
    " values {
      if {![info exists DB($values(cell))]} { set DB($values(cell)) [list] }
      lappend DB($values(cell)) [list $values(id) $values(pin) $values(direction) $values(relatedpin) $values(timing_type) $values(intrinsic)]
    }

    foreach cell [lsort -dictionary [array names DB]] {
  #     lappend output " Processing $cell"
      foreach elm $DB($cell) {
        foreach {id pin dir relatedpin type intrinsic} $elm { break }
#         lappend output "   Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
        drc "Found $dir pin '$pin' with '$type' check related to pin '$relatedpin' and 'intrinsic_${intrinsic}' attribute"
      }
    }
  } else {
    lappend output " UNSUPPORTED CHECK '[info level 0]' BY CURRENT DATABASE VERSION ($dbVersion)"
  }
  return -code ok
}


########################################################################################
# Main
########################################################################################

if {$sfilename != {}} {
  puts " -I- sourcing file '$sfilename'"
  source $sfilename
}

if {$showChecks} {
  # Only show DRC checks
  set tbl [::tb::prettyTable]
  $tbl header [list {Rule} {Severity} {Description}]
  $tbl configure -indent 2
  foreach elm $DRCDefn {
    foreach {rule enabled severity description} $elm { break }
    if {!$enabled} {
      continue
    }
    $tbl addrow [list $rule $severity $description]
  }
  puts [$tbl print]
  catch {$tbl destroy}
  # Now exit
  exit 0
}

if {$ofilename != {}} {
  set channel [open $ofilename {w}]
  puts $channel "# ----------------------------------------------------------------------\n"
  puts $channel [format "# Created on %s with reportDRC (%s)\n" [clock format [clock seconds]] $SCRIPT_VERSION ]
  puts $channel "# ----------------------------------------------------------------------\n"
}

# Iterate through each database
set numfile 1
foreach filename $ifilename {

  # SQLite3 database
  if {![file exists $filename]} {
    puts " -E- File '$filename' does not exist"
    set SQL {}
    continue
  }

  if {[llength $ifilename] > 1} {
    puts " -I- Processing database \[$numfile/[llength $ifilename]\]: [file normalize $filename]"
  }

  # Open SQLite3 database
  sqlite3 SQL $filename -readonly true
  wait_db_ready SQL

  # Get database version
  set dbVersion [SQL eval { SELECT value FROM param WHERE property='version' LIMIT 1; } ]

  set cells [SQL eval { SELECT name FROM cell ORDER BY name ASC }]

  set output {}
  catch {unset rules}

  ########################################################################################
  # Call DRCs
  ########################################################################################

  # If list of rules is empty, gather all the procs matching ARC-*
  if {[llength $allrules] == 0} {
    set allrules [info proc ARC-*]
  }
  foreach elm $DRCDefn {
    foreach {rule enabled severity description} $elm { break }
    if {[info proc $rule] == $rule} {
      if {([lsearch $allrules $rule] != -1) && [isDRCEnabled $rule]} {
#         if {$oformat == {default}} {
#           lappend output [format {
#    #######################################################################################################################
#    ##
#    ## %s [%s]
#    ##
#    #######################################################################################################################
#   } [getDRCDescription $rule] $rule]
#         }
        eval $rule
      }
    }
  }

  ########################################################################################
  # Build table of all violations
  ########################################################################################

  set tbl [::tb::prettyTable]
  $tbl header [list {Rule} {Severity} {Cell} {Pin} {Related Pin} {Message} {#} {Waived}]
  set columns [list 0 1 2 3 4 5]
  if {$showViolationNum} { lappend columns {6} }
  if {$showWaivers} { lappend columns {7} }
  $tbl configure -indent 2 -display_columns $columns
#   if {$showViolationNum} {
#     $tbl header [list {Rule} {Severity} {Cell} {Pin} {Related Pin} {Message} {#}]
#   } else {
#     $tbl header [list {Rule} {Severity} {Cell} {Pin} {Related Pin} {Message}]
#   }
  foreach el $csv {
    foreach {rule severity cell pin relatedpin msg num isWaived} $el { break }
    if {($isWaived == {Y}) && !$showWaivers} {
      # Skip DRCs that have been waived
      continue
    }
    $tbl addrow $el
  }
  if {!$showWaivers} {
    # Remove the column from the table so that it does not appear inside CSV
    $tbl delcolumns {7}
  }
#   puts [$tbl print]

  ########################################################################################
  # Print detailed report
  ########################################################################################

  # Print report
  if {!$summaryOnly} {
    switch $oformat {
      table {
        puts $channel [$tbl print]
        # Print out the $output Tcl list
        foreach line $output {
          puts $channel $line
        }
      }
      csv {
        set content {}
        $tbl export -format csv -return_var content
        puts $channel $content
        # Print out the $output Tcl list
        foreach line $output {
          puts $channel "# $line"
        }
      }
      default {
        set prev_rule {} ; set prev_cell {} ; set prev_pin {}
        foreach el $csv {
          foreach {rule severity cell pin relatedpin msg idx isWaived} $el { break }
          if {($isWaived == {Y}) && !$showWaivers} {
            # Skip DRCs that have been waived
            continue
          }
          if {$isWaived == {Y}} {
            set severity [format {%s (WAIVED)} $severity]
          }
          if {$rule != $prev_rule} {
            puts $channel [format {
   #######################################################################################################################
   ##
   ## %s [%s]
   ##
   #######################################################################################################################
  } [getDRCDescription $rule] $rule]
          }
          if {$cell != $prev_cell} {
            puts $channel " Processing $cell"
          }
          if {$showViolationNum} {
            puts $channel [format {    %s: %s [%s#%s]} $severity $msg $rule $idx]
          } else {
            puts $channel [format {    %s: %s [%s]} $severity $msg $rule]
          }
          set prev_rule $rule ; set prev_cell $cell ; set prev_pin $pin
        }
        # Print out the $output Tcl list
        foreach line $output {
          puts $channel $line
        }
      }
    }
    catch {$tbl destroy}
  }

  # Print summary
    puts $channel [format {
  ########################################################################################
  ##
  ## Summary of messages
  ##
  ########################################################################################
  }]
  set tbl [::tb::prettyTable]
  $tbl header [list {Rule} {Severity} {Messages} {Waived} {Description}]
  $tbl configure -indent 2
  foreach elm $DRCDefn {
    foreach {rule enabled severity description} $elm { break }
    if {!$enabled && $DEBUG} {
      if {[lsearch $allrules $rule] == -1} {
        continue
      }
      $tbl addrow [list $rule $severity {Disabled} {-} $description]
      continue
    } elseif {!$enabled} {
      continue
    }
    if {![info exists rules($rule)]} { set rules($rule) 0 }
    if {![info exists waivers($rule)]} { set waivers($rule) 0 }
    set num $rules($rule)
    if {($num == 0) && ($VERBOSE == 0)} {
      continue
    }
    if {[lsearch $allrules $rule] == -1} {
      continue
    }
    $tbl addrow [list $rule $severity $num $waivers($rule) $description]
  }
  if {$showWaivers} {
    set columns [list 0 1 2 3 4]
    $tbl configure -display_columns $columns
  } else {
    # Remove the column from the table so that it does not appear inside CSV
    $tbl delcolumns {3}
    # Since column '3' has been deleted, the previously column '4' is now '3'
    set columns [list 0 1 2 3]
    $tbl configure -display_columns $columns
  }
  switch $oformat {
    table {
      puts $channel [$tbl print]
      puts $channel ""
    }
    csv {
      puts $channel [$tbl export -format csv]
      puts $channel ""
    }
    default {
      puts $channel [$tbl print]
      puts $channel ""
    }
  }
  catch {$tbl destroy}

  # Closing the SQLite3 database
  SQL close

  incr numfile
}

# Closing the output file
if {($channel != {stdout}) && ($channel != {})} {
  close $channel
  set channel {}
  puts " -I- Generated file [file normalize $ofilename]"
}

exit 0
